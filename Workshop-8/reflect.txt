This week, I learned the meaning, usage, and syntax of smart pointers and the merits they have over raw pointers. Smart pointer, simply put, automate the process of allocating and deallocating the memory on the heap. With raw pointers, as they have no owner to guarantee their eventual release, it is our responsibility to free the memory at the end of their lifetime (end of the scope they have been initialized in). We enable safe exception handling with smart pointers; this occurs in some cases with raw pointers when a throw exception can cause a memory leak. However, due to the automatic destruction of the object, smart pointers prevent this memory leak to happen. The syntax for a smart pointer is different from a raw pointer in this way that we no longer are dealing with an expression. Smart pointers such as std::unique_ptr and shared_ptr are template functions and can act as a constructor. The constructor should explicitly get called; therefore, we cannot implicitly do it, as we used to with raw pointers, through the assignment operator. We define the type of the smart pointer between the angle brackets ("<") and we allocate the memory through the new keyword between the parenthesis. We can also not initialize the smart pointer upon creation and assign the pointers to it afterward through reset() and assign() functions.