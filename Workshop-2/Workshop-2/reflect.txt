/********************************************
///    Name:        Amirhossein Sabagh    ///
///    Student#:    152956199             ///
///    Email:       asabagh@myseneca.ca   ///
///    Date:        2021-01-31            ///
|*******************************************|
|********  Workshop 2 - Reflection  ********|
|*******************************************|

The most important concepts that were assessed in this workshop were the concept of move-constructor and move-assignment operator. The purpose was to demonstrate the superiority of move semantic over copy semantic; with move semantic, the program runs faster and more smoothly. The general difference between these two is that when we create an object based on an already existing one with copy semantic, what it does is it copies the elements and data members of the resource to the new object, while the move semantic moves the elements and the resource is afterward in a valid but unspecified state. In the workshop, when the copy operation is used, both StringSet object and the newly created SS object of type StringSet have the same content; we have two copies of the same elements in the memory and, therefore, it becomes costly for the program and memory. Using move operation, we swap the addresses of our two objects' resources with the help of std::move and then empty the object we performed the move operation on. What std::move does is it tells the compiler to consider the l-value an r-value for the period of the expression; when we do this, the assignment operator calls the move constructor. In the move constructor, we transfer the value of the pointer to the new object without duplicating the contents of the element. It is the implementation of the move constructor that makes the difference in performance; if in the move constructor we "steal" the content of the r-value, then we notice the significant difference. Something worth mentioning is that there is no difference between move semantic and copy semantic in terms of performance if the object(in our workshop, the class) doesn't have a resource(does not use dynamic memory allocation). 
Another thing I received help from was the functions of the fstream library. I made use of is_open(), eof(), clear(), and seekg() in my implementation to simplify my code and avoid complexity. I also got familiar with std::chrono library and learned how to monitor the time a task spends. That helped me to understand the difference between using the move semantic or the copy semantic.